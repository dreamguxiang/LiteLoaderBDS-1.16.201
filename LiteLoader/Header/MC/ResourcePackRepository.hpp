// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#define AUTO_GENERATED
#include "../Global.h"
#include "Core.hpp"

#define BEFORE_EXTRA
#include "ResourcePack.hpp"
#undef BEFORE_EXTRA

class ResourcePackRepository {

#define AFTER_EXTRA
public:
    struct KnownPackContainer {
        KnownPackContainer() = delete;
        KnownPackContainer(KnownPackContainer const&) = delete;
        KnownPackContainer(KnownPackContainer const&&) = delete;
    };
    LIAPI void setCustomResourcePackPath(PackType, const std::string& path);

    inline class PackSourceFactory & getPackSourceFactory(){
        //ResourcePackRepository::_initializeWorldPackSource Line62
        return dAccess<PackSourceFactory>(this, 46 * 8);
    };
#undef AFTER_EXTRA
#ifndef DISABLE_CONSTRUCTOR_PREVENTION_RESOURCEPACKREPOSITORY
public:
    class ResourcePackRepository& operator=(class ResourcePackRepository const &) = delete;
    ResourcePackRepository(class ResourcePackRepository const &) = delete;
    ResourcePackRepository() = delete;
#endif

public:
#ifdef ENABLE_VIRTUAL_FAKESYMBOL_RESOURCEPACKREPOSITORY
#endif
    MCAPI ResourcePackRepository(class IMinecraftEventing &, class PackManifestFactory &, class IContentAccessibilityProvider &, class Core::FilePathManager *, class PackSourceFactory &, bool);
    MCAPI void addInvalidPack(class ResourceLocation const &, enum PackType);
    MCAPI class Core::PathBuffer<std::string> const getDevelopmentBehaviorPacksPath() const;
    MCAPI class Core::PathBuffer<std::string> const getKnownPacksPath(enum KnownPackType) const;
    MCAPI class ResourcePack * getResourcePackForPackId(struct PackIdVersion const &) const;
    MCAPI class ResourcePack * getResourcePackInPath(class Core::Path const &) const;
    MCAPI class ResourcePack * getResourcePackSatisfiesPackId(struct PackIdVersion const &, bool) const;
    MCAPI class Core::PathBuffer<std::string> const getTreatmentPacksPath() const;
    MCAPI void refreshPacks();
    MCAPI void removePacksLoadedFromWorld();
    MCAPI ~ResourcePackRepository();
    MCAPI static std::string const BEHAVIOR_PACK_PATH;
    MCAPI static class mce::UUID const CHEMISTRY_PACK_UUID;
    MCAPI static class mce::UUID const CHEMISTRY_SERVER_PACK_UUID;
    MCAPI static std::string const DEVELOPMENT_BEHAVIOR_PACKS_PATH;
    MCAPI static std::string const DEVELOPMENT_RESOURCE_PACKS_PATH;
    MCAPI static std::string const DEVELOPMENT_SKIN_PACKS_PATH;
    MCAPI static std::vector<std::string> const EXPECTED_EXTENSIONS;
    MCAPI static class Core::PathBuffer<std::string> const GLOBAL_RESOURCE_PACKS_FILENAME;
    MCAPI static class Core::PathBuffer<std::string> const KNOWN_INVALID_PACKS_FILE_NAME;
    MCAPI static class Core::PathBuffer<std::string> const KNOWN_VALID_PACKS_FILE_NAME;
    MCAPI static std::string const RESOURCE_PACKS_PATH;
    MCAPI static std::string const SKIN_PACKS_PATH;
    MCAPI static std::string const TREATMENT_PACK_PATH;
    MCAPI static class Core::PathBuffer<std::string> getPremiumBehaviorPackPath();
    MCAPI static class Core::PathBuffer<std::string> getPremiumPackPath();
    MCAPI static class Core::PathBuffer<std::string> getPremiumResourcePackPath();

//private:
    MCAPI void _addResourcePackIfNotAlreadyAdded(class Pack &);
    MCAPI void _detectKnownPacksChange(struct ResourcePackRepository::KnownPackContainer &, struct ResourcePackRepository::KnownPackContainer const &, enum KnownPackType);
    MCAPI void _findVanillaPacks();
    MCAPI void _initialize();
    MCAPI void _initializePackSource();
    MCAPI void _initializeWorldPackSource();
    MCAPI void _loadLastKnownUserPacks(struct ResourcePackRepository::KnownPackContainer &, enum KnownPackType);
    MCAPI void _loadPacks(bool);
    MCAPI bool _packExists(class mce::UUID const &, class SemVersion const &, enum PackOrigin) const;
    MCAPI void _reloadDynamicPackagePacks();
    MCAPI void _reloadUserPacks();
    MCAPI bool _removePack(class ResourceLocation const &, bool);
    MCAPI void _saveKnownUserPacks(struct ResourcePackRepository::KnownPackContainer &, enum KnownPackType);
    MCAPI void _triggerRemoveResourcePackCallback(class ResourcePack *);

private:

};